\documentclass{article}

\usepackage{graphicx}
\graphicspath{{./images/}}

\usepackage{float}

\usepackage{listings}
\lstset{
	basicstyle=\ttfamily,
	columns=fullflexible,
	frame=single,
	breaklines=true,
	postbreak=\mbox{\textcolor{black}{$\hookrightarrow$}\space},
}

% margins of 1 inch:
\setlength{\topmargin}{-.5in}
\setlength{\textheight}{9.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\textwidth}{6.5in}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\begin{document}


% Relevant links and notes.
%
%	https://en.wikipedia.org/wiki/Deadlock
%	https://en.wikipedia.org/wiki/Discrete-event_simulation
%	http://sst-simulator.org/
%
%

    % https://stackoverflow.com/a/3408428/1164295
    \begin{minipage}[h]{\textwidth}
        \title{2022 Future Computing Summer Internship Project:\\Modeling Deadlock in a Discrete-Event Simulator to find Metrics to Measure its Existence in a Simulation.}
        \author{Nicholas Schantz\footnote{nickjohnschantz@gmail.com}}
        \date{\today}
            \maketitle
        \begin{abstract}
            \href{https://en.wikipedia.org/wiki/Deadlock}{Deadlock} is an issue that can occur in distributed systems in which multiple nodes connected in a circuit cannot proceed with any action because they are waiting for each other to take action as well. This research addresses the question as to whether metrics exist to determine if this problem has occurred in a distributed system simulation. These metrics are useful for system architects to monitor distributed system simulations and catch when deadlocking occurs, and they can fix any causes before the system is put into production. The \href{https://en.wikipedia.org/wiki/Discrete-event_simulation}{discrete-event simulator} (DES) framework called \href{http://sst-simulator.org/}{Structural Simulation Toolkit} (SST) is used to simulate this activity and find a metric. An SST model is created of a network of nodes in a \href{https://en.wikipedia.org/wiki/Ring_network}{ring topology} that pass messages in one direction to a connected nodes queue. Messages are generated by nodes and sent out which result in deadlock if the nodes queues fill up before the messages can reach their destination. Metrics to detect deadlock include measuring for a cycle of blocked nodes, how often a node changes from executing to idling, how many times they have requested a resource while idle, and how long they are idle. Utilizing these metrics, detection for system-scale deadlock was found. A global node that logs all other nodes' data can be used to determine if there is a high number of requests for nodes' queues but all nodes are in an idle state. Nodes can also self detect for deadlock by sending around a probe that will measure if a cycle of blocked nodes exist in the simulation. Further progress needs to be made regarding if metrics exist for detecting if a component-scale deadlock exist in a simulation.
            
            % OLD:SST will be used to model the problem and parameterized so that the problem can be simulated and metrics can be collected which identify if deadlock exist. Simulating the problem and determining if a system-scale deadlock has occurred is possible, but progress needs to be made regarding if metrics exist for detecting if a component-scale deadlock exist in a distributed system.
        \end{abstract}
    \end{minipage}

\ \\
% see https://en.wikipedia.org/wiki/George_H._Heilmeier#Heilmeier's_Catechism

%\maketitle

\section{Project Description} % what problem is being addressed? 

The challenge addressed by this work is to map the distributed systems problem Deadlock to a discrete-event simulator. Sandia National Laboratories' Structural Simulation Toolkit is a discrete-event simulator framework which is used to simulate the problem. Simulation output is collected to help identify mathematical or logical conditions that can cause this problem. This information is used to develop metrics to identify that the problem has occurred in simulated distributed systems.

\section{Motivation} % Why does this work matter? Who cares? If you're successful, what difference does it make?

% OLD Determining these metrics would allow for deadlock to be more easily identifiable in distributed systems than using algorithms to detect deadlock in the system. Metrics that identify the existence of the problem would help in creating better architecture to prevent the problem from occurring in distributed systems. The SST models written are resources that other users can use to learn and utilize SST's discrete event simulator.

Identifying the metrics to detect Deadlock will be vital for developing distributed systems that avoid this problem from occurring. Systems architects may be unaware of this problem or may not know that a deadlock can occur in their distributed system simulation. The metrics found in this research can help them catch this problem when they occur during the simulation's development. This will result in the problem being avoided in simulation so it does not occur when the system is put into production.

A second outcome of this work is to develop examples and documentation of SST simulations that new users can utilize. Currently, SST is primarily used for \href{https://en.wikipedia.org/wiki/High-performance_computing}{High-Performance Computing} (HPC) simulations and the majority of the SST examples revolve around modeling HPC systems. However, the SST framework utilizes a powerful discrete-event simulator that can model more than just HPC systems. The models and documentation created for this project show off the discrete-event simulations not relating to HPC systems.

\section{Prior work} % what does this build on?

See https://doi.org/10.1145/357360.357365 for information on deadlock detection but unrelated to metric gathering.
see %https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6312900
sse %https://tamcam.tamu.edu/Papers/multirev/multirev.htm

TODO

\section{Running the Model}

The software developed for this challenge was run on one laptop running an Ubuntu-Based Linux operating system.

\noindent The software is available on \href{https://github.com/lpsmodsim/2022HPCSummer-CongestiveCollapse}{https://github.com/lpsmodsim/2022HPCSummer-CongestiveCollapse}.\newline

\noindent Assuming the user is on a system running a Ubuntu-Based Linux Distro. To run the software:\newline

\noindent Prerequisites: 

\begin{verbatim}
	sudo apt install singularity black mypi
	git clone https://github.com/tactcomplabs/sst-containers.git
	cp sst-containers/singularity/sstpackage-11.1.0-ubuntu-20.04.sif /usr/local/bin/
	git clone https://github.com/lpsmodsim/2022HPCSummer-SST.git
	sudo . /2022HPCSummer-SST/additions.def.sh
\end{verbatim}

\begin{verbatim}
	git clone https://github.com/lpsmodsim/2022HPCSummer-Deadlock
	cd 2022HPCSummer-Deadlock/deadlock
	make
\end{verbatim}

\noindent To re-run the software:

\begin{verbatim}
	make clean
	make
\end{verbatim}

\noindent Expected Output:

\begin{lstlisting}[language=bash, frame=none]
mkdir -p .build
singularity exec /usr/local/bin/additions.sif g++ -std=c++1y -D__STDC_FORMAT_MACROS -fPIC -DHAVE_CONFIG_H -I/opt/SST/11.1.0/include -MMD -c node.cc -o .build/node.o
singularity exec /usr/local/bin/additions.sif g++ -std=c++1y -D__STDC_FORMAT_MACROS -fPIC -DHAVE_CONFIG_H -I/opt/SST/11.1.0/include -shared -fno-common -Wl,-undefined -Wl,dynamic_lookup -o libdeadlock.so .build/node.o
singularity exec /usr/local/bin/additions.sif sst-register deadlock deadlock_LIBDIR=/home/{USER}/sst-work/2022HPCSummer-Deadlock/deadlock
singularity exec /usr/local/bin/additions.sif black tests/*.py
singularity exec /usr/local/bin/additions.sif mypy tests/*.py
Success: no issues found in 2 source files
singularity exec /usr/local/bin/additions.sif sst tests/deadlockrand.py
(Simulation console output)
\end{lstlisting}

\noindent The simulation can be modified by editing the python driver file, it is located at:

\begin{verbatim}
	2022HPCSummer-Deadlock/tests/deadlock.py
\end{verbatim}

\section{Progress}
The models created for the deadlock problem were a network of \textit{n} nodes in a ring topology passing messages along the ring in one direction.

The model was built with the conditions for deadlock in mind. The conditions are the following\cite[p. 70]{1971_Coffman}:

\begin{itemize}
	\item Mutual Exclusion - Process has exclusive access to the resource it is holding.
	\item Wait for - A process will hold on to a resource while its waiting for a new one.
	\item No Preemption - A process cannot remove a resource from another process.
	\item Circular Wait - The processes who are holding and requesting resources form a cycle. \newline
\end{itemize}

These conditions can be related to the SST model by the following:

\begin{itemize}
	\item Mutual Exclusion - Each node has exclusive access to the next node's queue.
	\item Wait For - Each node waits and makes requests to send messages to the next node's finite queue.
	\item No Preemption - A node cannot force the next node to send messages out and free up its queue.
	\item Circular Wait - The nodes form a cyclic connection.
\end{itemize}

Two models with slight differences were created to demonstrate deadlock and how to detect the problem. The first model only consist of nodes in a ring topology, while the the second model introduces a node that collects logging data from all the nodes in the ring topology. The second model gives more freedom on how we can use information shared between all nodes to form metrics to detect deadlock in the simulation.

\begin{figure}[H]
	\includegraphics[scale=0.5]{deadlock}\newline
	\centering
	\caption{Example of first model with three nodes.}
	\centering
\end{figure}

\begin{figure}[H]
	\includegraphics[scale=0.5]{deadlocklog}\newline
	\centering
	\caption{Example of second model with three nodes connected to one central logging node. FIX DOT FILE: Connections incorrect}
	\centering
\end{figure}

An issue with these models is that the conditions for deadlock are baked into the models to force deadlock to occur. To improve the models, the conditions should be variable to get a more generalized system to collect metrics as to when deadlock exist in a simulation. This model is one specific example of deadlock in which measurements can be collected to detect why deadlock is occurring in this model, but does not determine for all cases if deadlock has occurred. For example, in a communication model of deadlock where messages are passed along, node's send rates can cause deadlocks to occur if all nodes' queues are filled up before messages reach their destination. However, send rate could be irrelevant for a deadlock occurring between processes grabbing resources. 

\section{Result} % conclusion/summary

Results found so far is that system-scale deadlock can be detected in a simulation. The metrics to detect for deadlock differ in the two models.

In the first model, a global logging node does not exist so a node can only initially detect that it is in a blocked state but does not know if the system is in deadlock. When a node detects that it is in a blocked state, an algorithm is used for it to detect if a system-scale deadlock has occurred. The algorithm is used to measure a cycle of blocked processes in the system and is based on the resource model deadlock detection found in \cite[p. 149]{1983_Chandy}. The algorithm utilizes messages called "probes" which are sent and read by other nodes immediately instead of being stored in a queue. When a node cannot access the next node's queue, it is blocked and will send out a probe to the next node. The probe will keep track of the originator and if the current holder is also blocked from sending messages. When the probe is received by a node, it will pass the probe along if it is in a blocked state, otherwise it will drop the probe. If a node receives a probe that originated from itself, then a ring of blocked nodes has been measured which means that the ring of nodes are deadlocked. In this model, this means that a system-scale deadlock has occurred since the model is made of a ring of nodes.

In the second model, a global logging node does exist which can keep track of all other nodes' states and determine if they are all in a blocked state. The global logging node will track what nodes are executing or idle, how many times they have requested to send a message to a connected nodes queue while idle, and how many times they have changed states during the simulation. From plotted data, deadlock will occur when all nodes idle time linearly increases, the amount of requests they make linearly increases, and the number of state changes becomes constant. 

An example simulation of the second model is demonstrated.

\begin{figure}[H]
	\includegraphics[scale=0.5]{dead-idle}\newline
	\centering
	\caption{\color{red} FIX: Update graphs with different line types. }
	\centering
\end{figure}

\begin{figure}[H]
	\includegraphics[scale=0.5]{dead-queue}\newline
	\centering
	\caption{\color{red} FIX: Update graphs with different line types.}
	\centering
\end{figure}

\begin{figure}[H]
	\includegraphics[scale=0.5]{dead-state}\newline
	\centering
	\caption{\color{red} FIX: Update graphs with different line types.}
	\centering
\end{figure}

Tracking all three of these metrics is a requirement to declare deadlock in the system. 

% OLD In the first model of the simulation where nodes do not share information with each other, a single node can determine when it is in a blocked state. The node will detect that it has been in a idle state for a predetermined set of time and it has been making request for a node's queue for a large number of time. At this point the node will send out a probe along the ring to determine if other nodes are currently executing. If any nodes are executing, they will drop the probe, otherwise they will pass the probe along. If the sender node receives its own probe, it determines that all nodes are in a deadlocked state so system-deadlock has occurred.

% OLD In the second model of the simulation where nodes share information with a global logging node, edge probing is not required. The logging node can determine when all nodes are in an idle state and have made a large amount of request for a node's queue.


\section{Future Work}
Currently, more work needs to be performed on detecting component-scale deadlock in a simulation.
TODO

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}
